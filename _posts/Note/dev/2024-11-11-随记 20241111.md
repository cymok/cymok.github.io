---
layout: post
tags: 随记
---

## java 线程池 实现方法

#### java 线程池

- 使用 ExecutorService 

```
// 创建一个固定大小的线程池
ExecutorService executorService = Executors.newFixedThreadPool(5); // 工厂方法创建线程池

// 提交任务
for (int i = 0; i < 10; i++) {
    executorService.submit(new Task(i)); // Task 是 Runnable 的实现类
}

// 关闭线程池
executorService.shutdown();
```

Executors 有多个工厂方法，可以创建各种线程池：固定大小的、能动态增加的、单线程的、定时任务的

- ThreadPoolExecutor 可以自定义线程池

#### kotlin 线程池、协程

Kotlin 没有独立的线程池实现，它依赖于 Java 的 java.util.concurrent 包中的线程池类

但是有协程 Coroutine，具有更高的性能和更低的资源消耗

协程可以使用自定义线程池作为调度器

```
    // 创建一个固定大小的线程池
    val threadPool = Executors.newFixedThreadPool(4).asCoroutineDispatcher()

    // 使用自定义线程池
    launch(threadPool) {
        println("Task on custom thread pool: ${Thread.currentThread().name}")
        delay(1000) // 模拟任务
    }
```

## 同步锁

  - 普通方法同步（实例方法同步），锁的是 this 对象，
  - 静态方法同步（类方法同步），锁的是 Class 类，无论多少对象调用，都竞争同一个锁

  - kotlin 同步锁依赖于 Java 的并发模型（因为也是基于 JVM）
    - @Synchronized 注解用在方法上，可用在 普通方法 和 静态方法（companion）
    - synchronized(obj){} 代码块上锁，放在方法里
    ```
    @Synchronized
        fun increment() {
            count++
        }
    ```
    - ReentrantLock（可重入锁）
    ```
    private var count = 0
    private val lock = ReentrantLock()

    fun increment() {
        lock.lock()  // 请求锁
        try {
            count++
        } finally {
            lock.unlock()  // 保证释放锁
        }
    }
    ```
	
	- ReadWriteLock（读写锁） 允许多个线程同时读取，但写操作是独占的
	```
	class Counter {
        private var count = 0
        private val lock = ReentrantReadWriteLock()
    
        fun increment() {
            lock.writeLock().lock()  // 获取写锁
            try {
                count++
            } finally {
                lock.writeLock().unlock()  // 释放写锁
            }
        }
    
        fun decrement() {
            lock.writeLock().lock()  // 获取写锁
            try {
                count--
            } finally {
                lock.writeLock().unlock()  // 释放写锁
            }
        }
    
		// 多个线程可以同时读取 getCount() 方法，但如果有线程写入（writeLock），则其他线程无法读取（readLock）
        fun getCount(): Int {
            lock.readLock().lock()  // 获取读锁
            try {
                return count
            } finally {
                lock.readLock().unlock()  // 释放读锁
            }
        }
    }
	```

## runBlocking launch 区别，返回值区别

- runBlocking 阻塞，返回协程的结果，return 的值
  - 用于主线程、测试 或需要等待结果的场景

- launch 非阻塞，返回 Job 表示协程的生命周期，用来取消或检测协程的状态
  - job.join() 将异步的 job 变成阻塞的
  - 用于后台或并发

job 没有提供直接的计算结果，需要结果用 async 将返回 Deferred，await 获取结果

```
fun main() = runBlocking {
    // 使用 async 启动一个协程，并获取返回值
    val deferred = async {
        delay(1000)
        "Hello from async!"
    }

    // 等待协程完成并获取结果
    println(deferred.await())  // 输出: Hello from async!
}
```

## 内联函数

优势

- 消除额外的函数调用开销：编译器会在调用处直接插入函数的代码，而不是进行函数调用

- 提高性能：
  - 避免创建大量的函数对象，从而提高性能（如 map、filter 等高阶函数）
  - 尤其是在函数调用栈比较深的情况下，内联函数可以减少栈的深度，降低内存使用和 CPU 的开销

限制：

- 无法内联递归函数：内联会展开函数的所有调用，而递归函数会导致无限的展开

- 发杂的返回类型：返回 lambda 或高阶函数，内联可能会失去效果，因为编译器可能需要创建一个函数对象

- 不能与泛型参数一起使用：内联函数不能用于具有泛型参数的函数，除非它们是 reified 类型参数

使用场景

- 高阶函数和 lambda 表达式：可以减少 lambda 表达式的创建和函数调用开销

- 自定义 DSL（领域特定语言）：可以实现更具表达力的代码

- 性能敏感代码：减少函数调用的开销

## 数据量 data class 特点

1. 自动为该类生成一些常见的方法

- **`toString()`**：返回类的字符串表示，包含类名和所有属性的值。

- **`equals()`**：根据类的所有属性自动实现相等性比较。

- **`hashCode()`**：根据类的所有属性自动生成哈希码。

- **`copy()`**：允许通过复制现有对象并对某些属性进行修改来创建新实例。

- **`componentN()`**：为每个属性生成对应的组件函数，允许通过解构声明提取属性值。
```
val user = User("Alice", 25)
val (name, age) = user  // 解构为 name 和 age
println(name)  // 输出：Alice
println(age)   // 输出：25
```

2. 只能是 Any 子类，不能继承其他类，也不能是 open 被继承

3. 主构造函数不能无参（带默认值可无参实例化），次构造可无参（次构造无参但是也要带默认值调用主构造）

4. 

## Kotlin 密封类 和 枚举类 区别

**主要区别**

| 特性                | **枚举类（Enum Class）**                           | **密封类（Sealed Class）**                               |
|--------------------|---------------------------------------------------|---------------------------------------------------------|
| **用法**           | 用于定义固定的常量集合，如状态、类别、方向等。   | 用于表示有多种子类类型的类层次结构，通常用于封装不同类型的状态。 |
| **继承方式**       | 枚举类的成员是固定的，不能继承。                 | 密封类的子类是有限的，且只能在同一个文件中定义。          |
| **多态支持**       | 适用于具有固定值的枚举项，不适用于继承层次。     | 适用于有多种不同类型或状态的场景，支持多态和类型安全。    |
| **成员类型**       | 每个枚举常量是该枚举类的实例，通常是常量。       | 子类可以是数据类、对象、普通类等，灵活多样。            |
| **可扩展性**       | 枚举类不能继承或扩展，成员是固定的。             | 密封类允许扩展，但扩展的子类必须在同一文件中。            |
| **适用场景**       | 常用来表示状态、标志、类型等离散值。             | 用于表达层次化的数据模型，处理不同类型的结果或状态。      |
| **与 `when` 配合** | 可以与 `when` 配合使用，但无法检查所有情况（缺少类型安全）。 | 与 `when` 配合时，能够保证所有情况都被处理，具有类型安全。  |

**选择使用哪一个**

- **使用枚举类**：
  - 当你需要表示一组固定的、离散的常量时，例如：
    - 日、月、星期几等。
    - 状态码或标识符。
    - 颜色、方向等有限的选项。
    
- **使用密封类**：
  - 当你需要表示多个不同类型的子类，并希望确保类型安全时，例如：
    - 状态的封装：例如网络请求的状态（成功、失败、加载中）。
    - 返回结果类型：例如操作的不同结果（成功、失败、未处理等）。
    - 错误处理：例如封装不同类型的错误（网络错误、数据错误、权限错误等）。

## ViewModel 优点

- 生命周期友好：被设计为生命周期感知型组件
- 避免内存泄漏：与 UI 分离，避免持有 Context，减少内存泄漏的风险
- 解耦：数据与 UI 分离
- 数据可观察：LiveData、StateFlow
- 简化配置：不要在 onSaveInstanceState、onRestoreInstanceState 手动处理
- 可测试性强：因为解耦了，单元测试更方便
- 共享数据：跨多个 Activity 或 Fragment 实例共享数据
- 处理 UI 状态：可观察数据，更方便处理复杂的 UI 状态
- 避免试图层过多的逻辑：在 ViewModel 处理逻辑，UI 层只关心展示数据，简化代码结构

## Java 引用

强引用（Strong Reference）：是普通的引用，直接指向对象。如果一个对象有强引用，它就不会被回收。

虚引用（Phantom Reference）：用于实现对象被回收时的通知机制，它不会影响垃圾回收的行为。
PhantomReference 只能与 ReferenceQueue 一起使用。

弱引用（WeakReference）：只要没有强引用，垃圾回收器就会回收该对象，适用于不再需要的对象，比如缓存管理和监听器注销。

软引用（SoftReference）：只有在内存不足时才会被回收，适用于内存缓存，可以让对象长时间存在，直到系统需要更多内存时才回收。

## 三方库源码 缓存机制，架构如何实现，有什么优秀的设计

### okhttp

#### 缓存机制

- HTTP 缓存头

- 缓存存储

- 缓存优秀策略

- 缓存回收与更新

- 缓存拦截器

#### 缓存的架构设计

- 请求拦截器 Interceptor
  - 使用拦截器模式来处理请求和响应的缓存，在请求服务器之前，先经过缓存拦截器，判断是否直接返回缓存
  - 响应数据也经过拦截器，缓存策略决定是否缓存

- 缓存控制器 Cache
  - 核心组件，负责磁盘缓存的存储与管理。每个缓存数据生成唯一 key
  - 缓存读取时 根据 HTTP 头信息（如 Cache-Control 和 Expires）判断是否过期，没有过期就返回缓存

- 缓存读取与写入
  - 请求时，会检查请求 URL 是否可以缓存（通过 Cache-Control），然后判断是否有有效的缓存，有缓存优秀返回缓存，没有则网络请求，并将响应数据存入缓存
  - 这种缓存读取和写入是同步的，因此可以确保请求的响应速度

- 缓存存储优化
  - 使用 DiskLruCache 来存储缓存文件，高效存取，避免缓存文件过大（LRU 清理）
  - 设置缓存大小来控制缓存空间

#### 优秀的设计

- 灵活的缓存策略：可配置不同的缓存策略。可控制有效期、也可通过拦截器实现自定义逻辑

- 响应式的缓存更新机制：缓存过期时，下次请求自动发起网络请求并更新缓存，保持最新的数据，不需要手动更新

- 高效的缓存存储：使用 DiskLruCache，它通过限制条目和总大小优化空间。LRU 最近最少使用策略，确保保留常用数据，减少存储开销

- 缓存透明度：开发者只需要配置基本的缓存策略（如缓存最大时长），框架会自动根据服务器响应和缓存策略来进行缓存的管理和更新

- 支持条件请求：通过 ETag 和 Last-Modified，OkHttp 支持条件请求。当缓存存在时，开发者可以使用这些头信息来判断资源是否改变，避免不必要请求


### glide

#### 缓存机制

- 内存缓存（Memory Cache）：快速加载，优先使用，LruCache 实现

- 磁盘缓存（Disk Cache）：缓存加载过的和处理过的图像，持久化，DiskLruCache 实现（会定期清理）

#### 缓存的架构

- 图像请求的初始化：
  - 根据缓存策略来决定从哪一层缓存获取数据（内存、磁盘 两层缓存）

- 内存缓存（Memory Cache）：
  - 优先在内存缓存中查找
  - 使用 LruCache 实现，根据内存大小和图像生命周期自动管理缓存

- 磁盘缓存（Disk Cache）：
  - 内存找不到，接着从磁盘查找，速度上慢些，但持久化
  - 使用 DiskLruCache 实现，按 URL 或者图像的某些标识符存储

- 网络请求（第三级缓存）：
  - 磁盘找不到，接着从网络请求图像数据，并进行两层缓存
  - 网络请求的图像经过转换（压缩、尺寸、裁剪等处理）也会存入缓存

- 缓存清理与管理：
  - 内存缓存清理：LruCache 会根据内存的使用情况和可用空间来自动清理。可配置缓存大小
  - 磁盘缓存清理：DiskLruCache 会根据磁盘空间限制和缓存策略来自动清理。会自动清理过期和不再需要的缓存

#### 缓存的设计实现

- LruCache（最少使用缓存）：使用双向链表和哈希表实现的快速查找和排序

- DiskLruCache（磁盘缓存）：使用文件系统存储缓存数据，在磁盘上实现了类似于内存缓存的 LRU 策略来管理文件。高效、持久化、自动清理

- 缓存清理策略：会定期清理缓存，防止占用设备资源。可配置，根据不同的缓存策略和存储空间，自动删除

- 资源类型的缓存：支持对不同类型，图像文件、Bitmap 对象、GIF 动画等。能够根据不同资源类型来合理地分配缓存空间

